
quick list of todo fancy features
  - nested pattern unification
  - weak Libal-Miller unification
  - partial substitution returning partial results
  - eliminator inversions
  - non-escaping meta optimization
  - local let-def preservation
  - observational def-eq coercions


Libal-Miller unification: https://www.lix.polytechnique.fr/Labo/Dale.Miller/papers/fcu-final.pdf

    - It's very hard to do in a full & stable way.
      Checking subterms is best done with hash-consing and eta-short normalization.
      Then, we have to somehow do tree matching during psubst. For that, starting
      with eta-short normal hash-consing on the rhs would also be an option.
      However, eta-short normal hash-consing is extremely expensive and doesn't
      support incremental unfolding.

    - We may try a simpler limited version:
        - Instead of checking subterm relations, we require bound variables to be *disjoint* in
          spine terms. If we invert some term, we only attach path information to the
          preorder-first bound var ("anchor"), and mark all other bound vars in the term as
          illegal. During psubst, if we hit an anchor var, we throw the anchor path as an exception
          and bubble up to the root of the path. At that point, we can do a conversion check to see
          if the inversion rule fires.
        - This is also rather complex, and I don't see an obvious way to do it in a nested way.
          Doing it in a nested way would be important, because nested pattern unification handles
          eta-expansions, and if I do Libal-Miller separately in the top spine, I have to do
          eta-reductions.

    - We might just hardwire simple cases like Lift, ElVal and ElComp. And see in practice which
      Libal-Miller problem pop up, to assess the practical benefit.


α (List A) =? List A → List A

  α := λ x. x → x

α (f x) (g x) =? f x → g x

α := λ x y. x → y

α x x =? x → x   -- no most general solution

α t₁ ... tₙ =? rhs









Optimization for non-escaping metas

  Most metas don't escape the scope of their creation, so we want to optimize for that case.
  Concretely, the cost of operations on non-escaping metas should not depend on the size of the
  local scope.

    - fresh meta creation is already O(1) in local scope
    - TODO metasub inversion should be O(1). We need to represent weakened identity env-s in values,
      shortcut inversion for that case.
    - TODO pruning should be O(1). Need to shortcut pruning subst creation if one meta scope is contained
      in the other one.

Inverting local defs

  Mapping to a defined domain var is an merely an *optimization* whose goal is preserving unfoldings,
  it can't fail in a hard way.

    - If inversion fails, we can simply continue; the only effect is that the domain definition will
      be unused in the solution (but may be still used in the solution type).
      When psubst-ing the solution candidate, we simply unfold those local defs which are not mapped
      in the psub.
    - We can invert codomain definitions opportunistically

  Example: "a" and "x" are both defined.

       a
     α x =? rhs
     x ↦ a
     α := λ a. rhs[x↦a]

     We simply rename local definitions.

  Example: "a", "x", "y" are defined

       a
    α (x, y) =? rhs
    x ↦ a.1
    y ↦ a.2
    α := λ a. rhs[x↦a.1, y↦a.2]

  Codomain local defs behave like bound vars for the purpose of inversion
  When inversion fails for a defvar-headed spine, we unfold and retry.

  We need two different modes for inversion
    - mapping to defvar: don't whnf, retry localdef inversion with unfolding
    - mapping to bvar: always whnf


Postponing

  - TODO
  - Need to track strong rigid/rigid/flex occurrences in errors
  - Need placeholders metas
  - NEW: fine-grain blocking: psubst failure gets *locally* replaced with placeholder metas
    - We bubble up to the outermost rigid or flex context
    - At *that* point we make a postponed problem and return a placeholder meta
    - Makes more progress than Agda!

  - Do we want to block on a single meta or more?
     In psubst, we might fail under multiple metas

  - JUST LEARNED ABOUT AGDA'S ANTI-UNIFICATION
    - Can we *just* keep unifying telescopes in a syntax-directed setting, by doing
      absolutely nothing???
    - Is this "typing modulo"?
    - IDEA: we relax the homogenity of unification. Since we only need homogenity for syntax-directed
      eta rules, we only need that:
        - when one side is Π, the other one is Π too with the same Icit-ness
        - when one side is a record, the other one is a record with the same arity

    - Does it even work?

         f : (b : Bool) → (if b then (Bool → Bool) else Bool) → C

         f true (λ x. x) =? f (α true) y

         postpone "true =? α true"

         (λ x. x : Bool → Bool) =? (y : if α true then (Bool → Bool) else Bool)

         No, it doesn't work!
         In Agda, anti-unification works because eta-expansion is type-directed,
         and it can only happen if both sides have Π/Σ type

    - Lesson: heterogeneous unification can make progress, but it requires computing types

    - Can we use some kind of computing meta-transport, without OTT or cubical, to get
      progress under postponed equality?

       f : (x : A) → B x → C
       f t u =? f t' u'

       cast (B t) (B t') u =? u'

       fancy "cast" operation which becomes definitional identity if t ≡ t'

      Basically: Yes, and it's probably a better solution than heterogeneous
      unification

Observational conversion
  TODO

Partial substitution returning partial result:
  TODO
  - if we have a soft failure of psubst, we bubble up to the enclosing strong
    rigid context and plug in a placeholder meta, and succeed.

Pruning
  TODO

TODO
  - copy from my sett version
  - except that partial values have transparent multi-closure defn
  - I don't have to check rhs type psubst in nested spine solution
     - because non-linear args always blow up there and we psubst
       every solution lambda binder anyway
  - But I do have to check it in top spine solution
     (if there's any non-linearity in the psubst)

TODO
  - We don't need Rhs data, because the head is always stored in the top of the rootEnv
  - "smart" spine reversals, also to reverse the metasubst


Local definition preservation:

  - It is kinda pointless to do anything more than mapping localdefs to localdefs!
    We can handle this case on the top, and then forget about def mapping everywhere else


----------------------------------------------------------------------------------------------------

BIG NEWS

Computational object functions SHOULD HAVE ETA but no beta ofc.

How does unification even work with eta but no beta??

What about basic pattern unif?

ValTy : Set

A     : ValTy
B     : Ty
A → B : CompTy

α : () ⊢ A → B

α () x =? x

α := λ x. x     is that good?

nope, beacuse (λ x. x) x /= x  !!!

so we *don't* have pattern unification

what about arg inversion?

α : (f : Nat0 → Nat0) ⊢ Nat0 → Nat0

α (λ x. f x) =? f

  λ x. f x ↦ a
  f ↦ λ x. a x

α (a) := λ x. a x

thus

α (λ x. f x) = λ x. (λ x. f x) x = λ x. f x    OK BUT WEIRD


α (λ x y. f y x) = f

  f ↦ λ x y. a y x

   α a = λ x y. a y x

α (λ x y . f y x) = λ x y. (λ x y. f y x) y x


α (λ x y. f y x) = f 10 20

  α (a) = a 20 10

So we can only do eta-reduction in args, but no general
nested inversion!!!

Computational product beta/eta seems reasonable

  - In arg inversion, we can still only do eta-reductions to variables
  - In spine solution:

       α .fst =? rhs
       α := (rhs, freshMeta)  OK

       In general, we can solve iterated projections

  - Will we need to have projection spines in Val0? (probably yes)

  - What about mixing splice into spines?


  α x y .~ .fst =? rhs
  α := λ x y. <rhs, freshMeta()>
  we need Stage 0 spine solving

  α .fst .snd .<> =? rhs



Level 0 arg inversion:

  - we can invert CRec & CProjection in a nested way
  - when we hit a lambda, we can only check eta-reduction to variable








----------------------------------------------------------------------------------------------------
