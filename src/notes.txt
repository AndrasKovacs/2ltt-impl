
Non-priorities:

- Detecting defn contractibility in Prop
- meta-level inductive families (+ fixpoints, case trees)

Preliminary designs

  - single file, no modules
  - we do top-level unshadowing by "Main.<topname>"
    - later we may move to a trie-like structure for module scope
    - trie for qualified scope + flat hashmap for unqualified scope
    - unqualified scope is O(N) time extended on every import
    - this is OK if we always merge the smaller table into the larger table

  - Overloaded data constructors are disambiguated by "TypeName.ConName"
  - Top things can't shadow except for overloaded data constructors


How to do Set/Prop?
  - Want it to be minimally intrusive
  - Sort-annotate neutrals?
  - Have up/down operation for sort switch?


Possible sort switches:

  cast: Prop inside Set           (1 variant out of 2)
  exfalso: Prop inside Set        (1 variant out of 2)
  app:                            (only 2 variant is a switch out of 4)
  proj:                           (only 1 variant is a switch out of 3)

  let:                            (2 out of 4 is switch)
  topdef:                         need to store S/P


  lam:    no switch!
  record: no switch!


Not a huge amount of switches... A bit suspicious but we'll see

- just make a "switch" variant for all of the above?
  only need

  cast sp       +1 variant
  exfalso sp    +1 variant

  app sp
  proj sp
  let sp

- If we don't make new variants, we only need SP annotation like the following:

  app       (arg)
  proj      (result)
  let       (definiens)

  we don't need annotation on coe and exfalso, because we always
  switch into Prop on the inside

  + annotation on Pi, because coe-Pi needs to know arg sort


Local meta optimization: an approximation of local scoping with only 2 modes:
  - metas which haven't yet escaped their scope are local
  - metas which escaped their scope are top-level contextual
  - we attach metas to scope levels on creation
  - we have to raise local metas when exiting scopes

Metas abstracting over local defs:
  TODO

Unification

  - generalized head inversion:
     - canonical and neutral inversions
     - how to avoid looping in canonical inversion? Fuel isn't stable.
       Cycle detection?
  - nested pattern unification Bocquet-style
  - Libal-Miller unification

Mutual blocks are not necessary!
  - We only allow forward decls in stage 0, but nothing in elaboration depends
    on the rhs-es of stage 0 definitions, so we don't need to group things together!
    Single top entries can be the unit of elaboration.



--------------------------------------------------------------------------------
