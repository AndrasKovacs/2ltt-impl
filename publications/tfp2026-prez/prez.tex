%% build: latexmk -pdf -pvc -xelatex prez.tex

\documentclass[dvipsnames,aspectratio=169]{beamer}
\usetheme{Madrid}

%% kill footline
\setbeamertemplate{footline}[frame number]{}
\setbeamertemplate{navigation symbols}{}
\setbeamertemplate{footline}{}

%% bibliography
\bibliographystyle{alpha}
\setbeamerfont{bibliography item}{size=\footnotesize}
\setbeamerfont{bibliography entry author}{size=\footnotesize}
\setbeamerfont{bibliography entry title}{size=\footnotesize}
\setbeamerfont{bibliography entry location}{size=\footnotesize}
\setbeamerfont{bibliography entry note}{size=\footnotesize}
\setbeamertemplate{bibliography item}{}

%% kill ball enumeration
\setbeamertemplate{enumerate items}[circle]
\setbeamertemplate{section in toc}[circle]

%% kill block shadows
\setbeamertemplate{blocks}[rounded][shadow=false]
\setbeamertemplate{title page}[default][colsep=-4bp,rounded=true]

%% kill ball itemize
\setbeamertemplate{itemize items}[circle]

%% --------------------------------------------------------------------------------

\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{cite}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{mathpartir}
\usepackage{scalerel}
\usepackage{stmaryrd}
\usepackage{bm}
\usepackage{graphicx}
\usepackage{fontspec}
\usepackage{textcomp}
\usepackage{fancyvrb}
\usepackage{tikz-cd}
\usepackage{minted}

\tikzcdset{scale cd/.style={every label/.append style={scale=#1},
    cells={nodes={scale=#1}}}}

\setmonofont[Scale=0.8]{DejaVu Sans Mono Bold}

%% --------------------------------------------------------------------------------

%% HoTT style composition
\makeatletter
\DeclareRobustCommand{\sqcdot}{\mathbin{\mathpalette\morphic@sqcdot\relax}}
\newcommand{\morphic@sqcdot}[2]{%
  \sbox\z@{$\m@th#1\centerdot$}%
  \ht\z@=.33333\ht\z@
  \vcenter{\box\z@}%
}
\makeatother

\renewcommand{\mit}[1]{{\mathit{#1}}}
\newcommand{\ttt}[1]{{\texttt{#1}}}
\newcommand{\msf}[1]{{\mathsf{#1}}}
\newcommand{\mbf}[1]{{\mathbf{#1}}}
\newcommand{\mbb}[1]{\mathbb{#1}}
\newcommand{\U}{\mathsf{U}}
\newcommand{\code}{\mathsf{code}}
\newcommand{\bs}[1]{\boldsymbol{#1}}
\newcommand{\wh}[1]{\widehat{#1}}
\newcommand{\mdo}{\mbf{do}\,}
\newcommand{\ind}{\hspace{1em}}
\newcommand{\bif}{\mbf{if}\,}
\newcommand{\bthen}{\mbf{then}\,}
\newcommand{\belse}{\mbf{else}\,}
\newcommand{\return}{\mbf{return}\,}
\newcommand{\pure}{\mbf{pure}\,}
\newcommand{\lam}{\lambda\,}
\newcommand{\data}{\mbf{data}\,}
\newcommand{\where}{\mbf{where}}
\newcommand{\M}{\msf{M}}
\newcommand{\letrec}{\mbf{letrec}\,}
\newcommand{\of}{\mbf{of}\,}
\newcommand{\go}{\mit{go}}
\newcommand{\add}{\mit{add}}
\newcommand{\letdef}{\mbf{let\,}}
\newcommand{\map}{\mit{map}}
\newcommand{\emptycon}{\scaleobj{.75}\bullet}
\newcommand{\Tyo}{\msf{Ty}_{\mbbo}}
\newcommand{\Tmo}{\msf{Tm}_{\mbbo}}
\newcommand{\whset}{\wh{\Set}}
\newcommand{\ev}{\mbb{E}}
\newcommand{\re}{\mbb{R}}


\newcommand{\mbbc}{\mbb{C}}
\newcommand{\mbbo}{\mbb{O}}

\newcommand{\vas}{\mathsf{as}}
\newcommand{\vbs}{\mathsf{bs}}
\newcommand{\vcs}{\mathsf{cs}}
\newcommand{\vxs}{\mathsf{xs}}
\newcommand{\vys}{\mathsf{ys}}
\newcommand{\vsp}{\mathsf{sp}}
\newcommand{\vma}{\mathsf{ma}}
\newcommand{\vga}{\mathsf{ga}}
\newcommand{\vm}{\mathsf{m}}
\newcommand{\vn}{\mathsf{n}}
\newcommand{\vk}{\mathsf{k}}
\newcommand{\vA}{\mathsf{A}}
\newcommand{\vB}{\mathsf{B}}
\newcommand{\vC}{\mathsf{C}}
\newcommand{\vS}{\mathsf{S}}
\newcommand{\vF}{\mathsf{F}}
\newcommand{\vR}{\mathsf{R}}
\newcommand{\vM}{\mathsf{M}}
\newcommand{\vmb}{\mathsf{mb}}
\newcommand{\mAs}{\mathsf{As}}
\newcommand{\va}{\mathsf{a}}
\newcommand{\vb}{\mathsf{b}}
\newcommand{\vc}{\mathsf{c}}
\newcommand{\vd}{\mathsf{d}}
\newcommand{\vx}{\mathsf{x}}
\newcommand{\vy}{\mathsf{y}}
\newcommand{\vz}{\mathsf{z}}
\newcommand{\vf}{\mathsf{f}}
\newcommand{\vfs}{\mathsf{fs}}
\newcommand{\vg}{\mathsf{g}}
\newcommand{\vh}{\mathsf{h}}
\newcommand{\vt}{\mathsf{t}}
\newcommand{\vs}{\mathsf{s}}
\newcommand{\vr}{\mathsf{r}}
\newcommand{\vu}{\mathsf{u}}
\newcommand{\vl}{\mathsf{l}}
\newcommand{\vns}{\mathsf{ns}}
\newcommand{\vW}{\mathsf{W}}
\newcommand{\vsup}{\mathsf{sup}}
\newcommand{\vid}{\mathsf{id}}
\newcommand{\whW}{\wh{\vW}}


\newcommand{\SOP}{\msf{SOP}}
\newcommand{\El}{\msf{El}}
\newcommand{\USOP}{\msf{U}_{\msf{SOP}}}
\newcommand{\Uprod}{\msf{U_P}}
\newcommand{\Elprod}{\msf{El_{P}}}
\newcommand{\IsSOP}{\msf{IsSOP}}
\newcommand{\forEach}{\msf{forEach}}
\newcommand{\single}{\msf{single}}
\newcommand{\msplit}{\msf{split}}
\newcommand{\mapGen}{\msf{mapGen}}
\newcommand{\genPull}{\msf{gen_{Pull}}}
\newcommand{\Set}{\msf{Set}}
\newcommand{\casePull}{\msf{case_{Pull}}}
\newcommand{\appull}{\ap_{\Pull}}

\newcommand{\Con}{\msf{Con}}
\newcommand{\Sub}{\msf{Sub}}
\newcommand{\Tm}{\msf{Tm}}
\newcommand{\Mor}{\msf{Tm}}

\newcommand{\ext}{\triangleright}

\newcommand{\Int}{\msf{Int}}
\newcommand{\List}{\msf{List}}
\newcommand{\Tree}{\msf{Tree}}
\newcommand{\Node}{\msf{Node}}
\newcommand{\Leaf}{\msf{Leaf}}
\newcommand{\Nil}{\msf{Nil}}
\newcommand{\Cons}{\msf{Cons}}
\newcommand{\Reader}{\msf{Reader}}
\newcommand{\ReaderT}{\msf{ReaderT}}
\newcommand{\Monad}{\msf{Monad}}
\newcommand{\Applicative}{\msf{Applicative}}
\newcommand{\class}{\msf{class}}
\newcommand{\Functor}{\msf{Functor}}
\newcommand{\Bool}{\msf{Bool}}
\newcommand{\Statel}{\msf{State}}
\newcommand{\fro}{\leftarrow}
\newcommand{\case}{\mbf{case\,}}
\newcommand{\foldr}{\msf{foldr}}
\newcommand{\foldl}{\msf{foldl}}
\newcommand{\rep}{\msf{rep}}
\newcommand{\concatMap}{\msf{concatMap}}

\newcommand{\Lift}{{\Uparrow}}
\newcommand{\Up}{{\Uparrow}}
\newcommand{\spl}{{\bs{\sim}}}
\newcommand{\ql}{{\bs{\langle}}}
\newcommand{\qr}{{\bs{\rangle}}}
\newcommand{\bind}{\mathbin{>\!\!>\mkern-6.7mu=}}

\newcommand{\MTy}{\msf{MetaTy}}
\newcommand{\MTm}{\msf{MetaTm}}
\newcommand{\VTy}{\msf{ValTy}}
\newcommand{\Ty}{\msf{Ty}}
\newcommand{\CTy}{\msf{CompTy}}
\newcommand{\True}{\msf{True}}
\newcommand{\False}{\msf{False}}
\newcommand{\fst}{\msf{fst}}
\newcommand{\snd}{\msf{snd}}

\newcommand{\blank}{{\mathord{\hspace{1pt}\text{--}\hspace{1pt}}}}

\newcommand{\Nat}{\msf{Nat}}
\newcommand{\Zero}{\msf{Zero}}
\newcommand{\Suc}{\msf{Suc}}
\newcommand{\Maybe}{\msf{Maybe}}
\newcommand{\MaybeT}{\msf{MaybeT}}
\newcommand{\Nothing}{\msf{Nothing}}
\newcommand{\Just}{\msf{Just}}

\theoremstyle{remark}
\newtheorem{notation}{Notation}
\newtheorem*{axiom}{Axiom}

\newcommand{\id}{\mit{id}}
\newcommand{\mup}{\mbf{up}}
\newcommand{\mdown}{\mbf{down}}
\newcommand{\tyclass}{\mbf{class}}
\newcommand{\instance}{\mbf{instance}\,}
\newcommand{\Improve}{\msf{Improve}}
\newcommand{\Gen}{\msf{Gen}}
\newcommand{\unGen}{\mit{unGen}}
\renewcommand{\Vec}{\msf{Vec}}
\newcommand{\gen}{\mit{gen}}
\newcommand{\genRec}{\mit{genRec}}
\newcommand{\fmap}{<\!\!\$\!\!>}
\newcommand{\ap}{{<\!\!*\!\!>}}
\newcommand{\runGen}{\mit{runGen}}
\newcommand{\qt}[1]{\ql#1\qr}
\newcommand{\lift}{\mit{lift}}
\newcommand{\liftGen}{\mit{liftGen}}
\newcommand{\MonadGen}{\msf{MonadGen}}
\newcommand{\MonadState}{\msf{MonadState}}
\newcommand{\MonadReader}{\msf{MonadReader}}
\newcommand{\RA}{\Rightarrow}
\newcommand{\EitherT}{\msf{EitherT}}
\newcommand{\Either}{\msf{Either}}
\newcommand{\Left}{\msf{Left}}
\newcommand{\Right}{\msf{Right}}
\newcommand{\StateT}{\msf{StateT}}
\newcommand{\Identity}{\msf{Identity}}

\newcommand{\Stop}{\msf{Stop}}
\newcommand{\Skip}{\msf{Skip}}
\newcommand{\Yield}{\msf{Yield}}

\newcommand{\runIdentity}{\mit{runIdentity}}
\newcommand{\runReaderT}{\mit{runReaderT}}
\newcommand{\newtype}{\mbf{newtype}\,}
\newcommand{\runMaybeT}{\mit{runMaybeT}}
\newcommand{\runStateT}{\mit{runStateT}}
\newcommand{\runState}{\mit{runState}}
\newcommand{\dlr}{\,\$\,}
\newcommand{\ImproveF}{\msf{ImproveF}}
\newcommand{\ExceptT}{\msf{ExceptT}}
\newcommand{\State}{\msf{State}}
\newcommand{\SumVS}{\msf{SumVS}}
\newcommand{\ProdCS}{\msf{ProdCS}}
\newcommand{\Here}{\msf{Here}}
\newcommand{\There}{\msf{There}}
\newcommand{\IsSumVS}{\msf{IsSumVS}}
\newcommand{\MonadJoin}{\msf{MonadJoin}}
\newcommand{\Stream}{\msf{Stream}}
\newcommand{\join}{\mit{join}}
\newcommand{\modify}{\mit{modify}}
\newcommand{\get}{\mit{get}}
\newcommand{\mput}{\mit{put}}
\newcommand{\Rep}{\mit{Rep}}
\newcommand{\encode}{\mit{encode}}
\newcommand{\decode}{\mit{decode}}
\newcommand{\mindex}{\mit{index}}
\newcommand{\mtabulate}{\mit{tabulate}}
\newcommand{\States}{\mit{States}}
\newcommand{\seed}{\mit{seed}}
\newcommand{\step}{\mit{step}}
\newcommand{\Step}{\msf{Step}}
\newcommand{\Pull}{\msf{Pull}}
\newcommand{\MkPull}{\msf{MkPull}}

\newcommand{\RED}[1]{{\color{BrickRed} #1}}
\newcommand{\GRN}[1]{{\color{OliveGreen} #1}}
\newcommand{\RBL}[1]{{\color{RoyalBlue} #1}}
\newcommand{\BLU}[1]{{\color{Blue} #1}}
\newcommand{\bsl}{\textbackslash}
\newcommand{\brl}{\textbraceleft}
\newcommand{\brr}{\textbraceright}

\newcommand{\vso}{\vspace{1em}}

%% --------------------------------------------------------------------------------

\title{Programming With Two-Level Type Theory}
\author{András Kovács}
\institute{University of Gothenburg \& Chalmers University of Technology}
\date{29th Jan 2026, TFP 26, Odense}
\begin{document}

\frame{\titlepage}


\begin{frame}{What is this about}

Unnamed WIP language for high-level high-performance programming.
\vso
\pause

\begin{itemize}
\item High-level: FP abstractions, generic programming, strong types.
\item High-performance: control over code generation, memory layout, allocation.
\end{itemize}
\vspace{1em}
\pause

Non-goal: ``systems'' programming.
\vso
\begin{itemize}
  \item We'll have substantial RTS with GC \& full memory safety.
\end{itemize}
\vso

Past implementations: smaller demo \cite{staged2ltt}, Agda \& Typed TH embedding \cite{DBLP:journals/pacmpl/Kovacs24}

Currently in early stage of development: \url{https://github.com/AndrasKovacs/2ltt-impl}

\vspace{1em}

\end{frame}


\begin{frame}{Motivation}

I'm interested in high-performance implementations of dependent type systems.
\vso

GHC Haskell has been my choice for performance:
\begin{itemize}
\item GC focused on throughput, OK machine code output, unboxed types, compact regions, efficient laziness (for the few cases when it's needed).
\end{itemize}
\vso

There are some performance issues or significant inconveniences in every other language I know.
\vso

Still: \emph{performance issues with GHC too} - motivating this research.

\end{frame}

%% \begin{frame}{Overview}

%% \begin{enumerate}
%% \item
%% \item 2LTT intro
%% \item Monads
%% \item Fusion
%% \item Memory layout control
%% \item Region allocation
%% \end{enumerate}

%% \end{frame}

\begin{frame}[fragile]{The GHC pipeline}

\[\begin{tikzcd}[scale cd=1.1, sep=normal]
	Source &&&&& Core &&&&& {...}
	\arrow["{Elaboration}"', from=1-1, to=1-6]
	\arrow["\begin{array}{c} Aggressive\\general\!-\!purpose\,optimization \end{array}", from=1-6, to=1-6, loop, in=55, out=125, distance=10mm]
	\arrow["Compilation"', from=1-6, to=1-11]
\end{tikzcd}\]

The optimizer is
\begin{itemize}
  \item Complex.
  \item Unstable across GHC versions.
  \item Supports limited user control.
\end{itemize}
\vso

\emph{A lot of idiomatic Haskell relies on it for acceptable performance.}


\end{frame}



%% \begin{frame}[fragile]{notes}

%% \begin{minted}{haskell}
%%   f :: Int -> Reader Bool Int
%%   f x = do
%%     b <- ask
%%     if b then return (x + 10)
%%          else return (x + 20)
%% \end{minted}

%% \end{frame}


\begin{frame}[fragile]{GHC example 1}

\begin{columns}
\begin{column}{0.3\textwidth}
\textbf{Source:}
\begin{minted}{haskell}

    f :: Reader Bool Int
    f = do
      b <- ask
      if b then return 10
           else return 20







\end{minted}
\end{column}
\pause
\begin{column}{0.5\textwidth}
\textbf{\texttt{-O0} Core output:}
\begin{minted}{haskell}

    dict1 :: Monad (Reader Int)
    dict1 = MkMonad ...

    dict2 :: MonadReader (Reader Int)
    dict2 = MkMonadReader ...

    f :: Reader Bool Int
    f = (>>=) dict1 (ask dict2) (\b ->
      case b of True  -> return dict1 10
                False -> return dict1 20)


\end{minted}
\end{column}
\end{columns}

\end{frame}

\begin{frame}[fragile]{GHC example 2}

\ttt{mapM} is third-order \& rank-2 polymorphic, but almost all use cases should
compile to first-order monomorphic code.
\vspace{1em}
\begin{minted}{haskell}
    mapM :: Monad m => (a -> m b) -> m [a] -> m [b]
\end{minted}
\vso


\end{frame}


\begin{frame}[fragile]{Revised pipeline}

\[\begin{tikzcd}[scale cd=1.0, sep=normal]
	Source && Metaprograms &&&& Object\,core &&& {...}
	\arrow["Elaboration"', from=1-1, to=1-3]
	\arrow["\substack{Compile\!-\!time\,\,execution \\ (unstaging)}"', from=1-3, to=1-7]
	\arrow["{Optimization}", from=1-7, to=1-7, loop, in=55, out=125, distance=5mm]
	\arrow["Compilation"', from=1-7, to=1-10]
\end{tikzcd}\]
\vso
\pause

The \emph{metalanguage} and the \emph{object language} should be different.

\begin{itemize}
  \item Simple object language supports better compilation \& performance.
  \item Dependent type theory as metalanguage.
\end{itemize}
\vso

\textbf{Main design question:} explicit control in object language vs.\ optimizations in the compiler.
\pause
\begin{itemize}
  \item The object language \textbf{can} be tedious as long as we can address tedium with metaprogramming!
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Setup}

Universes for stages:
\begin{itemize}
  \item \texttt{Set : Set} contains \textbf{dependent} meta-level types.
  \item \texttt{Ty : Set} contains \textbf{simple} object-level types.
  \item \texttt{ValTy : Set} and \texttt{CompTy : Set} are subtypes of \texttt{Ty} (polarization!).
\end{itemize}
\pause
Interaction between stages:
\begin{itemize}
\item \textbf{Lifting}: for \ttt{A : Ty}, we have \ttt{⇑A : Set}, as the type of
      metaprograms that produce \ttt{A}-typed object programs.
\item \textbf{Quoting}: for \ttt{t : A} and \ttt{A : Ty}, we have \ttt{<t> : ⇑A} as the metaprogram
      which immediately returns \ttt{t}.
\item \textbf{Splicing}: for \ttt{t : ⇑A}, we have \ttt{{\char`~}t : A} which runs the
       metaprogram \ttt{t} and inserts its output in some object-level code.
\item Definitional equalities: \ttt{{\char`~<}t{>} ≡ t} and \ttt{{<\char`~}t{>} ≡ t}.
\end{itemize}

\end{frame}


\begin{frame}[fragile]{The object level}

\textbf{An object-level program:}
\begin{verbatim}
  data List (A : ValTy) := nil | cons@Hp A (List A)

  f : List Int → List Int
  f xs := case xs of
    nil       → nil
    cons x xs → cons (x + 10) (f xs)
\end{verbatim}
\vso

Polarization:
\begin{itemize}
  \item Functions have value arguments and are computations.
  \item ADTs have value fields and are values.
\end{itemize}
\end{frame}

\begin{frame}[fragile]{The object level}

Explicit type former for closures:
\begin{verbatim}
  Close : CompTy → ValTy
  close : A → Close A
  open  : Close A → A
\end{verbatim}
\vso

Mapping with closures:
\begin{verbatim}
  map : Close (Int → Int) → List Int → List Int
  map f xs = case xs of
    nil       → nil
    cons x xs → cons (open f x) (map f xs)
\end{verbatim}
\vso

Closures are surprisingly rarely needed in practical programming!

\end{frame}


\begin{frame}[fragile]{Staging}

\begin{verbatim}
  inlineInt : ⇑Int
  inlineInt = <100>

  myInt : Int                                   myInt : Int
  myInt := 200                                  myInt := 200
                                 unstage
  id : {A : Ty} → ⇑A → ⇑A          ==>
  id x = x

  f : Int → Int                                 f : Int → Int
  f x := x + ~inlineInt                         f x := x + 100

  g : Int → Int                                 g : Int → Int
  g x := ~(id <x>)                              g x := x


\end{verbatim}

\end{frame}


\begin{frame}[fragile]{Staging}

Fully explicit \ttt{map}:
\begin{verbatim}
  map : {A B : ValTy} → (⇑A → ⇑B) -> ⇑(List A) → ⇑(List B)
  map {A}{B} f as = <
    let go : List ~A → List ~B
        go as := case as of
          nil       → nil {~B}
          cons a as → cons {~B} ~(f <a>) (go as)
    go ~as>

  monoMap : List Int -> List Int
  monoMap xs := ~(map (λ x. <~x + 10>) <xs>)
\end{verbatim}

\end{frame}


\begin{frame}[fragile]{Staging}

Unstaged output:
\begin{verbatim}
  monoMap : List Int → List Int
  monoMap xs :=
    let go : List Int → List Int
        go as := case as of
          nil       → nil {Int}
          cons a as → cons {Int} (a + 10) (go as)
    go xs
\end{verbatim}

\end{frame}


\begin{frame}[fragile]{Inference \& elaboration}

Quotes and splices are almost always inferable!

\begin{verbatim}
  map : {A B : ValTy} → (A → B) → List A → List B
  map f as =
    let go as := case as of
          nil       → nil
          cons a as → cons (f a) (go as)
    go as

  monoMap : List Int → List Int
  monoMap := map (λ x. x + 10)
\end{verbatim}

\end{frame}

\begin{frame}[fragile]{How to compile: monads}

Not easy! We want
\begin{itemize}
  \item guaranteed closure-freedom for everything except CPS monads
  \item guaranteed fusion for straight-line code (e.g.\ no intermediate constructor allocations in \ttt{Maybe})
  \item proper handling of join points and tail calls
  \item modest extra noise compared to Haskell
\end{itemize}
\vso
\pause

Ingredients of the solution:
\begin{itemize}
  \item The bulk of the logic is in a plain library.
  \item We use type classes \& \emph{implicit coercions}.
  \item Extra desugaring logic in \ttt{do}-blocks.
  \item Tail calls are handled by the downstream optimizer.
\end{itemize}

\end{frame}

\begin{frame}[fragile]{Monads: the bulk of the logic}

Monads only exist at compile time.
\begin{verbatim}
  class Monad (M : Set → Set) where
    pure  : {A : Set} → A → M A
    (>>=) : {A B : Set} → M A → (A → M B) → M B
\end{verbatim}

Recipe for porting over a transformer stack from Haskell:
\begin{enumerate}
\item We have an object-level type, same as in Haskell (but with polarities).
\item We have a meta-level transformer stack, which has an extra monad at the bottom, having
      \emph{code generation as an effect}.
\item We define back-and-forth conversion between the object-level type and the metamonad.
\end{enumerate}

\end{frame}

\begin{frame}[fragile]{The Gen monad}

\begin{verbatim}

  record Gen (A : Set) : Set = gen {unGen : {R : Ty} → (A → ⇑R) → ⇑R}

  instance Monad Gen where ...

  runGen : Gen ⇑A → ⇑A
  runGen (gen f) = f id

  class Monad M => MonadGen M where
    liftGen : Gen A → M A

  genLet : MonadGen M => ⇑A → M ⇑A
  genLet a = liftGen λ k. <let x := ~a; ~(k <x>)>
\end{verbatim}

\end{frame}


\begin{frame}[fragile]{The Gen monad}

\begin{verbatim}
  f : Int                                f : Int
  f := ~(runGen do           unstage     f :=
    x ← genLet <10 + 20>       ==>         let x := 10 + 20
    y ← genLet <~x * 10>                   let y := x * 10
    pure <~x + ~y>)                        x + y
\end{verbatim}

\end{frame}

\begin{frame}[fragile]{Case splitting in MonadGen}

\begin{verbatim}
  data BoolM : Set = trueM | falseM
  data Bool : ValTy := true | false

  down : BoolM → ⇑Bool
  down x = case x of trueM → <true>; falseM → <false>

  up : ⇑Bool → BoolM
  up = ?                -- impossible!
\end{verbatim}
\pause
However:
\begin{verbatim}
  up : MonadGen M => ⇑Bool → M BoolM
  up b = liftGen λ k. <case ~b of true → ~(k trueM); false → ~(k falseM)>
\end{verbatim}
\vso


\end{frame}


\begin{frame}[fragile]{Case splitting in MonadGen}

We add \textbf{extra desugaring} in \ttt{MonadGen} \ttt{do}-blocks for case splitting.
\begin{verbatim}
  f : Bool → Bool                        f : Bool → Bool
  f b := runGen do         elaborate     f b := ~(runGen do
    case b of                 ==>          b ← up <b>
      true  → pure false                   case b of
      false → pure true                      trueM  → pure <false>
                                             falseM → pure <true>)
\end{verbatim}
\vso

Every object-level case split can be handled analogously!

\end{frame}

\begin{frame}[fragile]{Monads in general}

Example: conversion between object-level type and a meta-monad.

\begin{verbatim}
                 ⇑(StateT Int (ReaderT Bool Identity) A)
                                  ↑ ↓
                 StateTM (⇑Int) (ReaderTM (⇑Bool) Gen) (⇑A)
\end{verbatim}

Generally: this conversion can be defined by recursion on the transformer stack (using
e.g. typeclasses) \cite{DBLP:journals/pacmpl/Kovacs24}.

\end{frame}


\begin{frame}[fragile]{Monads in general}

Code example:
\begin{verbatim}
M : Ty
M = StateT Int (ReaderT Bool Identity)

f : M ()                                   f : M ()
f := do                      elab +        f := stateT λ s. readerT λ r.
  b <- ask                   unstage         case r of
  n <- get                     ==>             true  → let s' := s + 10
  case b of                                            identity ((), s')
    true  → put $ n + 10                       false → let s' := s * 10
    false → put $ n * 10                               identity ((), s')
\end{verbatim}

\end{frame}

\begin{frame}[fragile]{Monads in general}

\begin{itemize}
\item A modest amount of extra noise compared to Haskell
      (but no native implementation yet!)
\item All of \ttt{mtl} works. Closures are only needed in \ttt{ContT}.
\item Note: \ttt{Reader} and \ttt{State} are computation types, so
      we need to wrap them in \ttt{Close} to store them in data structures.
\end{itemize}

\end{frame}

\begin{frame}[fragile]{Memory layout control}

All constructors are unboxed by default.
\begin{verbatim}
  data Pair (A B : ValTy) := pair A B
  data Sum (A B : ValTy) := left A | right B
\end{verbatim}

Recursive constructors must be guarded by a \emph{pointer to a region}.
\ttt{Hp} is the general GC-d heap.
\begin{verbatim}
  data List A := nil | cons@Hp A (List A)
\end{verbatim}

Weird sum type with just one unboxed constructor:
\begin{verbatim}
  data Sum A B := left A | right@Hp B
\end{verbatim}

\end{frame}

\begin{frame}[fragile]{Tag-free GC \& bit-stealing}

GC is \emph{almost tag-free}: only 1 bit metadata per heap object.
\vso

Bit-stealing: any data can be stored in unused bits in pointers
or constructor fields.
\vso

Large space savings compared to pretty much any managed RTS language.

\end{frame}

\begin{frame}[fragile]{Tag-free GC \& bit-stealing}

Example: pure lambda terms with 32-bit variables.
\begin{verbatim}
data Tm := var UInt32 | app@Hp Tm Tm | lam@Hp Tm
\end{verbatim}
Layout of \ttt{app (var 0) (var 1)}
\begin{verbatim}
  | app | ptr |                 -- 1 word
           ↓
        | var | 0 | var | 1 |   -- 2 words
\end{verbatim}
In GHC:
\begin{verbatim}
  | app | ptr |                              -- 1 word
           ↓
        | app    | ptr         | ptr |       -- 3 words
                    ↓             ↓
                 | var | 0 |   | var | 1 |   -- 4 words
\end{verbatim}

\end{frame}

\begin{frame}[fragile]{Tag-free GC \& bit-stealing}

Implementation: explored back in the 90s \cite{DBLP:conf/lfp/Tolmach94}.
\vso

In a simple type theory, it's enough to know the types (memory layouts) of GC roots.
\vso

For each monotype, we generate code for GC scanning \& copying.
\vso

Only \emph{stack frames} need to store runtime type information about roots.

\end{frame}

\begin{frame}[fragile]{Regions}

\begin{verbatim}
  Location : Set
  Hp       : Location
  Region   : Set
\end{verbatim}
There's implicit coercion from \ttt{Region} to \ttt{Location}. The object language
supports dependent functions of the form \ttt{(R : Region) → ...}.
\vso

Lists with cons cells in a specified location:
\begin{verbatim}
  data List (L : Location) (A : ValTy) := nil | cons@L A (List L A)
\end{verbatim}

\end{frame}


\begin{frame}[fragile]{Regions}

Example: list in a local region.
\begin{verbatim}
  sum : {R : Region} → List R Int → Int
  sum xs := case xs of nil → 0; cons x xs → x + sum xs

  countDown : {R : Region} → Int → List R Int
  countDown x := case x of 0 → nil
                           n → cons x (countDown (x - 1))

  f : Int → Int
  f x :=
    let R : Region
    let xs : List R Int := countDown x
    sum xs
\end{verbatim}

\end{frame}

\begin{frame}[fragile]{Type-directed GC scanning}

\textbf{Example 1}: if a list contains no heap pointers, GC doesn't touch it!
\vso
\pause

Why? Assume we have \ttt{xs : List R Int} in scope where \ttt{R : Region}.
\vso
\pause

The region \ttt{R} itself is present at runtime, and it serves as a GC root
for the whole region.

\vso
\pause
Since the whole region is kept alive by the \ttt{R} reference, there's no need to
scan the list.

\end{frame}

\begin{frame}[fragile]{Type-directed GC scanning}

\textbf{Example 2:} let's have \ttt{data HpPtr A := box@Hp A} and consider \ttt{List R (HpPtr Int)}.
\vso
\pause

GC scans values of \ttt{List R (HpPtr Int)} because it needs to scan the general heap pointers
inside. But it doesn't copy the list cells.
\vso
\pause

\textbf{Example 3:} \ttt{List R (Close (Int → Int))}. Closures can capture arbitrary data, including
heap pointers, so we also need to scan them!
\vso
\pause

\textbf{Example 4:} \ttt{List Hp Int}. The cons cells are on the general heap, so
we scan and possibly copy everything.

\end{frame}

\begin{frame}[fragile]{Existential regions}

\begin{verbatim}
data InSomeRegion (L : Location) (F : Region → ValTy) :=
  inSomeRegion@L (R : Region) (F R)
\end{verbatim}

We can also \emph{hash regions} and compare for them equality.
\vso

So we can store regions in data structures and manage them at runtime.
\vso

\emph{The more we know about lifetimes, the more we can speed up GC by moving data into regions}.
\vso

If we don't care, we can ignore regions with \emph{no burden} on programmers.

\end{frame}


\begin{frame}[fragile]{Related}

\textbf{1. GHC compact regions}\cite{DBLP:conf/icfp/YangCAEKN15}
\begin{itemize}
  \item We can create compact regions.
  \item There's a primop to \emph{deeply copy} GHC objects into the region.
  \item Hence: a compact region only contains internal pointers.
  \item GC doesn't scan regions. A region is alive as long as any object
    in it is alive.
  \item Very important in Agda!
\end{itemize}
\pause

\textbf{2. Rust lifetimes}
\begin{itemize}
  \item Deterministic \& precise tracking of where objects get destroyed.
  \item Sub-structural typing.
\end{itemize}

\end{frame}


\begin{frame}[fragile]{The problem with sub-structural typing}

\alert{We don't know how to make it work nicely with staging.}
\vso

Consider an application rule for linear functions:
\begin{verbatim}
    Γ ⊢ t : A ⊸ B   Δ ⊢ u : A
    ──────────────────────────
          Γ,Δ ⊢ t u : B
\end{verbatim}
\vso

The semantic (operational) meaning of \ttt{⇑A → ⇑B} in 2LTT:
\begin{itemize}
  \item We map object term to object terms in \emph{arbitrary} object contexts.
  \item The mapping \emph{commutes with substitutions}.
\end{itemize}
\vso

We can't inhabit \ttt{⇑(A ⊸ B) → ⇑A → ⇑B}. No idea if the free variables
are disjoint.


\end{frame}

\begin{frame}[fragile]{Structuralizing things}

\textbf{1. Massage sub-structural features into structural shape}
\begin{itemize}
  \item Erasure control by Constantine Theocharis (unpublished).
  \item Closure capture control by AK (unpublished).
\end{itemize}
\vso

\textbf{2. Other structural features}
\begin{itemize}
  \item ST monad, monadic regions.
  \item Disentanglement typing for thread-local GC \cite{10.1145/3776655}.
\end{itemize}

\end{frame}

\begin{frame}[fragile]{Further topics}

\begin{itemize}
  \item Staged fusion.
  \item IR optimizations.
  \item Backend compilation, LLVM.
\end{itemize}
\pause
\vso
\vso

\center\large Thank you!

\end{frame}





\bibliography{references}

\end{document}
